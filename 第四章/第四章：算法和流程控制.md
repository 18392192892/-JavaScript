## 第四章：算法和流程控制

@(高性能JavaScript)

本章针对三种算法流程优化 `js`

### 一丶循环

在大多数编程语言中，代码执行事件大部分消耗在**循环**中。循环处理是最常见的编程模式之一，也是提升性能必须关注的点。

#### 循环性能

在 `js` 中除去数组的遍历方法，和调用遍历器的`for...of`，总共有四种循环方法

分别是 `for`，`while`，`do...while`，`for...in`

在这四种循环中，只有 `for...in` 循环相对于其他三种有明显的区别，其余三种相差不多。

原因很明显，因为 `for...in` 循环每次迭代的操作都会同时搜索**实例**和**原型属性**，所以在每次迭代的时候会**产生更多开销**。

对比相同迭代次数的循环，`for-in`循环最终只有其他类型速度的 **1/7**，这个数值不是很准确，因为现在的浏览器有去优化这个循环方法。

不过深究哪种循环最快没有什么意义，因为循环类型的选择应该基于**需求**而不是**性能**

很简单，如果你要遍历原型上的属性就使用 `for-in`，如果你不需要遍历原型上的属性就使用其他循环类型。

#### 其他提高性能的方法

如果在循环类型与性能无关的情况下，还有两个因素可以用来优化循环的性能。

- 每次迭代处理的事务
- 迭代的次数

通过减少这两者中的一个或者全部的时间开销，你就能提升循环的整体性能

#### 减少迭代的工作量

第一个提升的方法就是**限制循环中耗时操作的数量**

一个典型的数组循环可以采用三种循环的任何一种，最常见的写法如下

```javascript
for (let i = 0; i < items.length; i++) {
	console.log(items[i]);
}
```

那上面的循环中，每次运行循环体时都会产生如下操作：

1. 在控制条件中查找一次属性（`items.length`）
2. 在控制条件中执行一次数值比较（`i < items.length`）
3. 一次比较操作查看控制条件的计算结果是否为 `true`（`i < items.length == true`）
4. 一次自增操作（`i++`）
5. 一次数组查找（`items[i]`）
6. 一次 `console.log`

这些操作中，有些是必须的，有些却可以省略以提高效率。

比如，我们可以将第一步省略，每次循环都要查找 `items.length` 是一个很费时的操作。可以通过在初始化的时候将 `items.length` 缓存。

```javascript
for (let i = 0, len = items.length; i < len; i++) {
	//...
}
```

这样就不需要每次去查找 `items.length` 的具体值了。

还可以省略的是第二步。

我们的目的循环完整个数组，那我们可以通过一个倒序遍历

```javascript
for (let i = items.length; i--; ) {
	// ...
}
```
这样就直接通过对比 `i` 和 `true` 的值进行结束判断。

倒叙循环省略了第一步和第二步。

这种优化方式仁者见仁吧，因为可读性确实变差了，而且循环的结束条件也不一定是遍历完数组。

#### 减少迭代次数

即使循环题中执行最快的代码，累计迭代上千次也会慢下来，所以需要减少迭代的次数。

那么有一种限制循环迭代次数的模式，称为**达夫设备**

这是一个转化迭代的方法

比如我们有下面的操作

```javascript
let items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for (let i = 0, len = items.length; i < len; i++) {
	console.log(arr[i]);
}
```
这个循环我们需要循环 10 次，可以用达夫设备优化为 8 次。

```javascript
	let items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
	let num = Math.floor(items.length / 8);
	let startAt = items.length % 8;
	let i = 0;
	do {
		switch(startAt) {
			case 0: console.log(items[i++]);
			case 7: console.log(items[i++]);
			case 6: console.log(items[i++]);
			case 5: console.log(items[i++]);
			case 4: console.log(items[i++]);
			case 3: console.log(items[i++]);
			case 2: console.log(items[i++]);
			case 1: console.log(items[i++]);
		}
		startAt = 0;
	} while (num--);
```

达夫设备利用了 `switch` 的坠落性，没有写 `break`，他会一直执行下去。

这个方法相当于把循环的次数降低了8倍。

不过这种优化方式还是需要看使用场景，首先达夫设备的可读性不是很高，而且循环的语句如果不止一条，那就需要另外封装一个函数，又是一件麻烦的事。

但是如果性能真的因为循环而降低，可以考虑这种优化方式。

### 二丶条件语句

条件语句虽然不会产生大量性能问题，但是多少还是会有一些

#### if-else 和 switch

对于这两个方法的使用，主要还是通过需求而不是性能。

这两种语句的性能差别只有在**条件数量非常多**的时候才会显示出来，在有大量的条件数量下，`switch`的性能会比`if-else`好，数量少的时候没有太大的区别。

一般使用是条件语句多就使用 `switch`，如果少就使用 `if-else`，这样做是为了可读性好。

#### 优化 if-else

这里说一种优化 `if-else` 的方法。

如果我们所要寻找的值**位于条件语句很后面的位置**，那相当于每一条判断语句都需要执行。所以我们的优化目标是：**最小化到达正确分支前所需要判断的条件数量**。

这里就需要使用二分的思想了。

将判断的条件，从中间分开，先判断前半段，再判断后半段，然后在前半段种再先判断前半段，以此类推，可以达到最少的判断次数。

#### 查找表

有些时候优化条件语句的最佳方案是避免使用 `if-else` 和 `siwtch`。

当有大量离散值需要测试时，`if-else` 和 `switch` 比使用查找表慢很多。

在 `js` 中可以使用数组和普通对象来构建一个**查找表**，通过查找表访问数据比用 `if-else` 和 `switch` 快很多，特别在条件语句数量很大的时候。

比如我们要查找一个`value === 0`的值

```javascript
if (value === 0) {
	console.log('zhao')
}
```
我们可以把它放到一个数组中 

```javascript
let items = ['zhao', 'li'];
console.log(items[value]);
```

如果数据多了，查找表会比条件语句快很多。

### 三丶递归

对于递归，性能一直是一个问题，因为它会不停的创建一个**函数执行上下文**。

直到达到浏览器允许的调用栈最大数量。如果调用过多，就会发生**爆栈**，也就是**栈溢出**。

而且相较于迭代，递归的性能比迭代差很多。

所以如果特别注重性能的话，可以用迭代去替代递归，**任何递归能实现的算法同样可以使用迭代来实现**

#### 避免重复工作

在使用递归的时候，很容易造成重复的工作。

比如一个计算阶乘的函数

```javascript
	function factorial(num) {
		return num === 1 ? 1 : factorial(num - 1) * num;
	}
```

当我们多次执行这个函数时，会有多次重复计算，比如计算 6 的阶乘，其实就是在 5 的阶乘上乘以 6 ，之后如果再计算 7 的阶乘，又需要重新计算。这样就做了许多无用功。

我们可以通过给**函数添加属性**来**缓存**计算过的值

```javascript
	function factorial(num) {
		if (!factorial.cache) {
			factorial.cache = {
				'1': 1
			}
		}
		if (!factorial.cache.hasOwnProperty(num)) {
			factorial.cache[num] = factorial(num - 1) * num;
		}
		return factorial.cache[num];
	}
```
我们将计算过的值缓存在函数的 `cache` 属性中，下次计算前先检查这个属性中是否包含要计算的值。

如果没有就继续计算，有就直接返回。这样当我们执行多次函数的时候，就不会再做无用功了

当然这种优化方法的前提是每次计算**所得的结果相同**，如果不相同这个方法就用不了了。

### 总结

和其他编程语言一样代码的写法和算法会影响运行时间，主要有以下几点

- `js` 中共四种循环，除了 `for-in` 其余的三种性能相差不多。
	- 尽量不要使用 `for-in`，除非你真的需要
	- 改善循环的方式有两种，一种是**减少每次迭代的运算量**，一种是**减少迭代的次数**
		- 减少运算量可以使用**倒叙循环**
		- 减少迭代次数可以使用**达夫设备**
- 两种条件语句相差不多，在条件语句特别多的情况下，建议写`switch`。
	- `if-else` 的优化一般可以使用二分的思想
	- 如果数据实在多，可以用**查找表**代替条件语句
- 递归的性能总是比循环低，而且如果递归过多会引起**栈溢出**的情况
	- 可以用迭代替代递归，但是编码效率会降低
	- 在递归会进行重复计算的情况下，缓存计算过的值来避免重复计算。

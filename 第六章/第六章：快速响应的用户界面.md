## 第六章：快速响应的用户界面

@(高性能JavaScript)

### 一丶浏览器 UI 线程 

我们之前也说过，浏览器对于 `UI` 渲染和 `js` 引擎，只分配一个线程。这也就意味着当我们执行 `js` 的时候，`UI` 是会挂起等待的。

`UI` 线程的工作基于一个简单的**队列系统**，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。

这些任务要么是 `js` 代码，要么是执行 `UI` 更新，包括重排和重绘。这其实是一个事件循环的过程，具体的不多讲。

一个 `js` 脚本执行的时候，所有 `UI` 更新都会排在队列里等待更新，直到脚本文件执行完成，`UI` 才能夺回线权，然后更新 `UI`。

如果用户试图在任务运行期间与页面交互，不仅没有即时的 `UI` 更新，甚至可能新的 `UI` 更新任务都不会被创建并加入队列，所以要尽快结束 `js` 任务，以避免对用户体验造成不良影响。

#### 浏览器限制

浏览器限制了 `js` 任务的运行事件，这种限制是很有必要的。它确保某些恶意代码不能通过**永不停止的密集操作**锁住用户的浏览器或计算机。

有两种限制：**调用栈限制**和**长时间运行脚本限制**

浏览器会记录一个脚本的运行时间，并在达到一定限度时终止它。

不同的浏览器检测长时间运行脚本的方法略有不同。

有的是记录自脚本开始依赖**执行的语句的数量**。有的是记录脚本**执行的总时长**。

#### 最好用户体验的时长

浏览器允许脚本持续的最长时间并不是你允许脚本持续的最长时间。浏览器允许脚本持续运行好几秒，但这并不意味着你也允许它这样做。

事实上，为了更好的用户体验，你的 `js` 代码运行的时间应该**远远小于**浏览器的限制。

单个 `js` 操作花费的总时间不应该超过 100 毫秒。如果 `js` 运行时间超过 100 毫秒，用户就会感觉失去了对界面的控制。

所以在脚本运行期间不论执行什么点击事件，`UI` 都不会有变化。**在一个脚本运行期间点击一个按钮，将无法看到它被按下的样式，尽管它的 `onclick` 事件处理器会被执行**

因此最好的方法就是限制所有 `js` 任务在 100 毫秒或更短的时间内完成，以避免类似的情况出现。

### 二丶使用定时器让出时间片段

可能有些 `js` 文件过大，即使你已经做了很大的努力了，但是还是会超过 100 ms。

这个时候我们可以通过定时器，让出 `UI` 线程的控制权，使得 `UI` 可以更新。让出控制权意味着停止执行 `js`，使 `UI` 线程有机会更新，然后再继续执行 `js`。

定时器的基础我们就不说了。

这里利用的原理就是事件循环，因为 `UI` 更新是放在一次宏任务后进行的，所以可以把运行时间较长的任务放在定时器内，然后让 `UI` 先渲染一次，再执行时间较长的任务。

#### 分割任务

如果在一个 `js` 中有一个时间过长的任务，我们可以将它分成几个小任务，并通过定时器去分段执行，可以大大提升执行效率

比如有这样一段代码

```javascript
function saveDocument(id) {
	oneDocument(id);
	twoDocument(id);
	threeDocument(id);
	fourDocument(id);
}
```
我们这个任务总共需要 200ms 才能执行完成。

如果直接执行会导致用户能感受到卡顿，这个时候需要我们改变一下。

通过定时器将这段代码分成四部分去执行就可以避免浏览器无法更新 `UI`

```javascript
function saveDocument(id) {
	let task = [oneDocument, twoDocument, threeDocument, fourDocument];
	setTimeout(() => {
		let task = task.shift();
		task(id);
		if (tasks.length > 0) {
			setTimeout(arguments.callee, 25);
		}
	})
}
```

通过这个方法，就可以让浏览器每隔 `25ms` 就把线圈还给 `UI` 一次，让他进行渲染。然后再去执行其他的任务。

#### 记录代码运行的时间

上面的方法很好，但也有一些小问题，如果分段执行后，一个小任务的执行时间很短，那就很难完美利用定时器了。

比如说现在有一个需要执行 1000个小任务 的任务，其中一个小任务执行时间为 1ms，使用定时器每隔 25ms 执行一个任务，那么执行这个任务总共需要 `(25 + 1) * 1000 = 26000ms`，那如果定时器每次执行 50 个任务，执行时间就会变为 `(1000 / 50) * 25 + 1000 = 1500ms`，只需要 1500ms。

所以在执行期间可以根据任务执行的时间从而决定一次执行多少个任务。

我们通过一个函数来看一下具体执行过程

```javascript
function timeProcessArray(items, procee,callback) {
	let todo = items.concat();
	setTimeout(() => {
		let start = +new Date();
		do {
			process(todo.shift());
		} while(todo.length > 0 && (+new Date() - start < 50));
		if (todo.length > 0) {
			setTimeout(arguments.callee, 25);
		} else {
			callback(items);
		}
	}, 25);
}
```

每次执行完代码以后都会检查，时间是否超过了 50ms ，如果没有超过就继续执行，直到超过 50ms。

#### 定时器与性能

对于定时器来说，定时器本身也会效果性能，所以**过度使用定时器**也会对性能造成负面影响。

一次创建一个定时器不会有什么问题，但是当多个重复定时器同时创建的时候，会产生性能问题。

尤其是那种频率较高的定时器，比如每隔 `100ms` 到 `200ms`之间就会执行一次的定时器，这种高频定时器会严重影响性能。

在 Web 应用中限制高频率重复定时器的数量。

### 三丶Web Workers

对于 `web workers` 的使用方法，我们这里还是不讲，主要讲述一下， `web works` 对于性能的提升。

`web works` 可以给 `Web` 引用用带来潜在的巨大的性能提升，因为每个新的 `worker` 都在自己的线程中运行代码。

#### Worker 运行环境

由于 Web Workers 没有绑定 UI 线程，这也意味着它们**不能访问浏览器的许多资源**。

`js` 和 UI 共享统一进程的部分原因是它们之间**互相访问频繁**。但是每个 Web Workers 都有自己的全局运行环境，其功能只是 `js` 特性的一个子集。

#### 实际应用

Web Workers适用于那些处理**纯数据**，或者与**浏览器 UI 无关**的**长时间**运行脚本。

如果我们要解析一个很大的 `JSON` 字符串，假设数据量足够庞大，至少需要 500ms 才能完成解析，很明显时间太长了，超出了客户端允许 `js` 运行的时间，因为它会干扰用户体验。而且此任务很难去通过定时器分解，因此这个时候 Worker 就称为最理想的解决方案了。

解析一个大字符串只是许多受益于 Web Workers 的任务之一。其他可能受益的任务如下：

- 编码/解码大字符串
- 复杂数学运算
- 大数组排序

任何超过 100ms 的处理过程，都应该先考虑使用 Web Worlers。


### 总结

`js` 和用户界面更新在同一个进程中运行，因此一次只能处理一件事情。

高效的管理 UI 线程就是要确保 `js` 不能运行太长时间，以免影响用户体验。

- 任何 `js` 任务，浏览器都有最长的执行时间，如果超过了最长执行时间就会报错
- 但是为了用户体验，`js`任务不应该超过 100ms，过长的运行时间会导致 UI 更新出现明显的延迟，从而对用户体验产生负面影响。
- 可以通过定时器将一个执行时间很长的任务分割成一些小任务，来达到优化的目的
- Web Wrokers当然是解决这个问题的不二选择，它允许你在 UI 线程外部执行 `js` 代码，从而避免锁定 UI


## 第三章：DOM编程

@(高性能JavaScript)

用脚本操作 DOM 的代价非常大，它是 Web 应用中最常见的性能瓶颈。

### 一丶浏览器中的DOM

文档对象模型是一个独立于语言的，用于操作 XML 和 HTML 文档的程序接口。

尽管 DOM 是个与语言无关的 API，它在浏览器中的接口却是用 `js` 实现的。

#### 天生就慢

操作DOM对于性能意味着什么呢。

**两个相互独立的功能只通过彼此接口链接，就会产生消耗。**

就好比 DOM 和 JS 是两座岛屿，它们之间用收费桥梁链接，JS 每次 访问 DOM ，都要途径这座桥，并缴纳**过桥费**，访问的 DOM 次数越高，缴纳的费用就越高。

推荐的做法是尽可能的减少过桥的次数，也就是**尽可能的减少操作 DOM 的次数**


### 二丶HTML集合

#### 低效之源

HTML 集合是包含了 DOM 节点引用的**类数组对象**。以下方法的返回值就是一个集合：

- `document.getElementsByName()`
- `document.getElementsByClassName()`
- `document.getElementsByTagName()`

下面的属性同样返回 HTML 集合

`document.images`：页面中所有 `img` 元素
`document.links`：页面中所有 `a` 元素
`document.forms`：所有表单元素

这种 HTML 集合对象是一个**类数组列表**。

正如 DOM 标准中所定义的，HTML 集以一种 **假定实时态** 实时存在，这意味着**当底层文档对象更新时，它也会自动更新**

所以 **HTML 集合一直与文档保持着链接**，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数也是如此。这正是**低效之源**

为了演示集合的实时性，考虑以下代码片段

```javascript
let dom = document.getElementsByTagName('div');
for (let i = 0; i < dom.length; i++) {
	document.body.appendChild(document.createElement('div'));
}
```
这段代码看上去只是简单的把页面中的`div`元素数量翻倍。但事实上这是一个死循环。

因为循环的退出条件 `dom.length` 在每次迭代的时候都会增加，**它反映出的是底层文档的当前状态**

解决这个问题很简单，只需要把 `dom.length` 先缓存一下就可以了。

#### 解决HTML集合带来的性能问题

这样低效的集合，我们该如何提高性能呢，有如下几点

##### 1. 首先将长度和元素对象缓存

结合上一章的内容，因为 `document` 是一个全局对象，所以访问它上面的方法和属性应该尽可能的少，**将获取下来的节点缓存在局部变量中**

像下面这样

```javascript
let dom = document.getElementsByTagName('div');
for (let i = 0, len = dom.length; i < len; i++) {
	console.log(dom[i]);
}
```
这样每次获取局部变量 `dom` 就可以了，而且长度也缓存下来，不会重复执行查询的过程。

##### 2. 能合并成一次的操作就合并成一次

如果我们要不停的修改一个元素的 `innerHTML`，代码是这样

```javascript
for (let i = 0; i < 1500; i++) {
	document.getElementById('here').innerHTML += 'a';
}
```

优化一下可以是这样
```javascript
let dom = document.getElementById('here');
for (let i = 0; i < 1500; i++) {
	dom.innerHTML += 'a';
}
```

但是这样的效率还是低，这样的循环相当于我们访问了1500次`dom`，我们完全可以先在`js`上完成，然后只访问一次 `dom`，比如这样

```javascript
let dom = document.getElementById('here');
let content = ''
for (let i = 0; i < 1500; i++) {
	content += 'a';
}
dom.innerHTML = content;
```

这样实际上我们只操作了一次 `dom`，大大优化了新能

##### 3. 用数组存储HTML集合

如果不能合并操作，还要频繁的操作 `dom`，可以将`dom`缓存在一个数组中。

```
let coll = document.getElementsByTagName('div');
let arr = [...new Set(coll)];
```

然后我们操作这个 `arr` 就可以了。

**注意：**这个方法会因为额外的步骤带来额外的消耗，所以应当评估当下环境是否适用，如果操作非常频繁就可以用这个方法，如果只是操作一次，那其实可以不用

##### 4. 换个 API 

既然这个元素集合性能如此低下，我们直接可以舍弃它，换用 CSS 选择器定位节点。

现在浏览器支持两种方法，是 `querySelectorAll()` 和 `querySelector()`。

这两种方法适用 CSS 选择器作为参数并返回一个 `NodeList`。它不是一个 HTML 集合，**因此返回的节点不会对应实时的文档结构**。

这样就可以避免 HTML 集合引起的性能问题

### 三丶重排与重绘

重排与重绘的具体过程这里不再赘述，简单介绍一下

重排：当DOM的变化影响了元素的**几何属性**，浏览器需要重新计算几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为**重排**

重绘：完成重排后，浏览器会重新绘制受到影响的部分到屏幕中，该过程称为**重绘**。如果没有改变元素的几何大小和位置，只是改变了颜色这种属性，就只会触发重绘

**重绘不一定重排，但是重排一定重绘**

重绘和重排都是代价昂贵的操作，它们会导致 Web 应用程序的 UI 反应迟钝。**所以，应该尽量减少这类过程的发生**

#### 触发重排的操作

重排主要会在以下几种情况中触发

- 添加或删除可见的 DOM 元素
- 元素位置改变
- 元素尺寸改变
- 内容改变
- 页面渲染器初始化
- 浏览器窗口尺寸改变

#### 渲染树变化的排队和刷新

由于每次重排会产生计算消耗，所以大多数浏览器通过**队列化修改并批量执行来优化重排过程**

具体的重排时间是在**一轮宏任务和相对应的微任务完成之后**，执行一次渲染。

```javascript
	let box = document.querySelector('#box');
	box.style.backgroundColor = 'black';
	box.style.width = '400px';
	box.style.height = '200px';
	setTimeout(() => {
		console.log('下一轮宏任务');
	}, 2000);
	// 将定时器添加到时间队列后，在这里批量渲染
```

在上面的代码中，它并不是添加一句修改样式的命令就执行一次渲染，而是放入一个队列，在宏任务完成之后**批量渲染**

浏览器的这个操作可以说大大的优化了性能。

但是，**你可能会不经意间强制刷新队列并要求立刻渲染**。获取**布局信息**的操作会导致队列刷新，比如下面的方法

- offset系列(top, left, right, bottom)
- scroll系列(top, left, right, bottom)
- client系列

以上属性和方法需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的**待处理变化**并触发重排以返回正确的值。

所以在修改样式的过程中，最好避免使用上面列出的属性。它们都会刷新渲染队列，即使你是在获取**最近未发生改变**的或者**与最新改变无关的布局信息**

如果要使用这些值，一定在多次修改后调用，让浏览器能够进行**批量渲染**

#### 最小化重排与重绘

尽管浏览器会帮助我们合并渲染，但是因为**查找属性的方法**和一些**导致当前宏任务结束的方法**会导致立刻渲染，所以我们自己最好还是不要修改内联样式。

而是将要改变的属性合并写成 `css`，通过修改元素的 `class` 达到修改元素属性的目的。

或者我们可以使用 `cssText`，一次性修改内联样式。

#### 批量修改 DOM

如果要对 DOM 元素进行一系列的操作，可以通过以下步骤来减少重绘和重排的次数：

1. 使元素脱离文档流
2. 对其进行多重改变
3. 把元素带回文档中

有三种方法可以实现这个步骤。

##### 1. 隐藏元素

我们可以使用 `display: none` 这个属性，从文档中移除要改变的元素，然后进行多重的改变。

##### 2. 文档碎片

另一种减少重排次数的办法是，**在文档之外创建并更新一个文档片段，然后把它附加到原始列表中。**

文档片段是一个轻量级的 `document` 对象，它的设计初衷就是为了完成这类任务，**更新加移动节点**

下面的代码中只触发了一次重排，而且只访问了一次实时的 DOM 
```javascript
let fragment = document.createDocumentFragment();
appendDataToElement(fragment, data); // 进行大量dom操作
document.getElementById('mylist').appendChild(f);
```

##### 3. 节点克隆

第三个方法是为需要修改的节点创建一个备份，然后对副本进行操作，一旦操作完成，使用新的节点替代旧的节点

```javascript
let old = document.getElementById('mylist');
let clone = old.cloneNode(true);
appendDataToElement(clone, data); // 进行大量dom操作
old.parentNode.replaceChild(clone, old);
```

推荐使用文档片段，因为它们所产生的DOM遍历和重排次数最少。

#### 动画的影响

如果我们使用 `js` 写动画，会造成大量的重排和重绘，可以使用以下步骤优化

1. 使用**绝对定位**让需要添加动画的元素脱离正常文档流。
2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是**页面一个小区域的重绘过程**，不会产生重排并重绘页面的大部分内容。
3. 当动画结束时恢复定位，从而只会重排两次

而且在使用 `js` 写动画的时候，我们应该将数据信息缓存。

比如我们做一个扩大宽度的动画

```javascript
let current = dom.offsetWidth;
setTimeout(() => {
	current++; 
	dom.style.width = current + 'px';
}, 16);
```

### 四丶事件委托

如果页面中存在大量元素，而且每一个都要一次或多次绑定事件处理器时，这种情况可能会影响性能。每绑定一个事件处理器都是有代价的。

事件处理器要么会**加重页面负担**，要么**增加了运行期的执行时间**。需要访问和修改的 DOM 元素越多，应用程序也就越慢。

所以如果给所有元素都添加绑定事件是一件很恐怖的事情。

一个简单而优雅的处理 DOM事件的技术就是**事件委托**。它可以完美解决我们所说的问题。

因为事件逐层冒泡并能够被父级元素捕获，所以我们可以给父级元素绑定一个事件处理器，通过对比**目标对象**触发不同子元素上的方法即可。

### 总结

访问和操作 DOM 就是现在 Web 应用最重要的部分，为了减少 DOM 编程带来的性能损失，有以下几点：

- HTML 集合是一个实时的类数组，底层文档更新的时候它也会更新，这就造成了许多性能问题。
	- 缓存需要访问的元素和元素长度
	- 尽可能少的访问 DOM ，合并操作
	- 可以将HTML集合保存在一个数组中，操作数组
	- 使用 `querySelectorAll` 方法
- 浏览器重排和重绘也会造成性能影响
	- 修改样式的时候，将所有样式放到一个 `class` 中，修改类名
	- 操作DOM的时候，要批量修改
		- 使用 `display: none` 隐藏元素，然后进行修改
		- 使用 **文档片段**
		- 使用 节点克隆
	- `js` 书写动画的时候，将元素通过**绝对定位**脱离文档流，只进行重绘不进行重排
- 在有大量元素需要绑定事件处理器时，可以通过**事件委托**